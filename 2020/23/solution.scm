(import (chicken io)
        (chicken process-context)
        (srfi 1))

(define (import-input path)
  (map string->number (map string (string->list (read-line (open-input-file path))))))

(define (link-input input)
  (let ((array (make-vector (+ (length input) 1) 0)))
    (for-each
      (lambda (a b)
        (vector-set! array a b))
      input (append (cdr input) (list (car input))))
    array))

(define (play array input n)
  (let ((m (- (vector-length array) 1)))
    (let play/h/1 ((t (car input)) (x 0))
      (unless (= x n)
        (let* ((a (vector-ref array t))
               (b (vector-ref array a))
               (c (vector-ref array b))
               (v t))
          (let ((s (let play/h/2 ((v (- v 1)))
                     (cond ((or (= v a)
                                (= v b)
                                (= v c))
                            (play/h/2 (- v 1)))
                           ((= 0 v)
                            (play/h/2 m))
                           (else v)))))
            (vector-set! array t (vector-ref array c))
            (vector-set! array c (vector-ref array s))
            (vector-set! array s a)
            (play/h/1 (vector-ref array t) (+ x 1))))))))

(define (solve/1 input)
  (let ((array (link-input input)))
    (play array input 100)
    (print (let solve/1/h ((x 0) (acc 0) (current (vector-ref array 1)))
             (if (= x (- (length input) 1))
                 acc
                 (solve/1/h (+ x 1) (+ (* acc 10) current) (vector-ref array current)))))))

(define (solve/2 input)
  (let* ((len (length input)) (input (append input (iota (- 1000000 len) (+ len 1)))) (array (link-input input)))
    (play array input 10000000)
    (let* ((a (vector-ref array 1))
           (b (vector-ref array a)))
      (print (* a b)))))

(let ((path (car (command-line-arguments))))
  (let ((input (import-input path)))
    (solve/1 input)
    (solve/2 input)))
