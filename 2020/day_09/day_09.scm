(import (chicken io)
        (chicken process-context)
        (srfi 1)
        (srfi 113)
        (srfi 128))

(define (import-input path)
  (map string->number (read-lines (open-input-file path))))

(define (generate-bag pre)
  (let ((acc (bag (make-default-comparator))))
    (do ((i pre (cdr i))) ((null? i))
      (do ((j (cdr i) (cdr j))) ((null? j))
        (let ((a (car i))
              (b (car j)))
          (bag-adjoin! acc (+ a b)))))
    acc))

(define (solve/1 input)
  (let* ((pre (take input 25))
         (lst (drop input 25))
         (acc (generate-bag pre)))
    (let solve/1/h ((pre pre) (lst lst))
      (if (bag-contains? acc (car lst))
          (begin
            (for-each (lambda (i) (bag-delete! acc (+ i (car pre)))) (cdr pre))
            (for-each (lambda (i) (bag-adjoin! acc (+ i (car lst)))) (cdr pre))
            (solve/1/h (append (cdr pre) (list (car lst))) (cdr lst)))
          (car lst)))))

(define (solve/2 part/1 input)
  (print (call/cc
           (lambda (return)
             (do ((input input (cdr input))) ((null? input))
               (let solve/2/h ((lst input) (acc (list)) (sum 0))
                 (cond ((= sum part/1) (return (+ (apply max acc)
                                                  (apply min acc))))
                       ((< sum part/1)
                        (solve/2/h (cdr lst) (cons (car lst) acc) (+ sum (car lst)))))))))))

(let ((path (car (command-line-arguments))))
  (let* ((input (import-input path)) (part/1 (solve/1 input)))
    (print part/1)
    (solve/2 part/1 input)))
