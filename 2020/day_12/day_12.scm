(import (chicken io)
        (chicken process-context)
        (matchable)
        (srfi 1))

(define (import-input path)
  (map
    (lambda (str)
      (let ((lst (string->list str)))
        (list (string->symbol (list->string (take lst 1)))
              (string->number (list->string (drop lst 1))))))
    (read-lines (open-input-file path))))

(define (solve/1 input)
  (let ((dirs (vector `E `S `W `N)))
    (define (solve/1/h input x y index)
      (if (null? input)
          (list x y)
          (match (car input)
            (`(N ,num) (solve/1/h (cdr input) (- x num) y index))
            (`(S ,num) (solve/1/h (cdr input) (+ x num) y index))
            (`(E ,num) (solve/1/h (cdr input) x (+ y num) index))
            (`(W ,num) (solve/1/h (cdr input) x (- y num) index))
            (`(L ,num) (solve/1/h (cdr input) x y (modulo (+ index (- (/ num 90)) 4) 4)))
            (`(R ,num) (solve/1/h (cdr input) x y (modulo (+ index (+ (/ num 90)) 4) 4)))
            (`(F ,num) (solve/1/h (cons (list (vector-ref dirs index) num) (cdr input)) x y index)))))
    (print (apply + (map abs (solve/1/h input 0 0 0))))))

(define (solve/2 input)
  (define (rotate/cc x y n)
    (let rotate/cc/h ((x x) (y y) (n n))
      (if (= n 0) (list x y) (rotate/cc/h (- y) x (- n 1)))))
  (define (rotate/c  x y n)
    (let rotate/c/h  ((x x) (y y) (n n))
      (if (= n 0) (list x y) (rotate/c/h  y (- x) (- n 1)))))
  (define (solve/2/h input ship-x ship-y way-x way-y)
    (if (null? input)
        (list ship-x ship-y)
        (match (car input)
          (`(N ,num) (solve/2/h (cdr input) ship-x ship-y (- way-x num) way-y))
          (`(S ,num) (solve/2/h (cdr input) ship-x ship-y (+ way-x num) way-y))
          (`(E ,num) (solve/2/h (cdr input) ship-x ship-y way-x (+ way-y num)))
          (`(W ,num) (solve/2/h (cdr input) ship-x ship-y way-x (- way-y num)))
          (`(L ,num) (match (rotate/cc way-x way-y (/ num 90)) ((x y) (solve/2/h (cdr input) ship-x ship-y x y))))
          (`(R ,num) (match (rotate/c  way-x way-y (/ num 90)) ((x y) (solve/2/h (cdr input) ship-x ship-y x y))))
          (`(F ,num) (solve/2/h (cdr input) (+ ship-x (* num way-x)) (+ ship-y (* num way-y)) way-x way-y)))))
  (print (apply + (map abs (solve/2/h input 0 0 -1 10)))))

(let ((path (car (command-line-arguments))))
  (let ((input (import-input path)))
    (solve/1 input)
    (solve/2 input)))
